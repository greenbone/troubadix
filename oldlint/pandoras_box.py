#!/usr/bin/env python3

import subprocess, sys, re, os, getopt
from sys import version_info, exit

if version_info < (3,):
    exit("Python < 3 is not supported")

cur_changed_counter = 0
max_changed_counter = 100

has_modified = False
modified_only = True
recursive = True
dry_run = False
cur_recursion_level = 0
single_file = ".nasl"
start_dir = "./scripts"
staged_only = False
use_commit_range = False
passed_commit_range = ""


def help():
    print(
        "Usage: "
        + sys.argv[0]
        + " [-h --help, -m --modified-only, --staged-only, --commit-range <range>, -a --all --batch, -s <startdir> --start-dir <startdir>, -f <filename> --single-file <filename>, --non-recursive, -c --max-counter, --dry-run]"
    )
    print("\nParameters:")
    print("\t-h, --help: This help output")
    print(
        "\t-m, --modified-only: (default, optional) Appending this will only change the scripts which have been modified by the user"
    )
    print(
        "\t--staged-only: Only run against files which are 'staged/added' in git"
    )
    print(
        "\t--commit-range: (optional, only used if -a / --all wasn't passed) Allows to specify a git commit range (e.g. '$commit-hash1...$commit-hash2' or 'HEAD~1') to run the script against."
    )
    print(
        "\t-a, --all, --batch: (optional) Appending this will run the script on the current ./scripts dir or a specific file/dir passed via the next two parameters"
    )
    print(
        "\t-s, --startdir <startdir>: (optional, defaults to ./scripts) Allows to choose the dir which should be used by the script as a start dir. If no files within this dir where modified -a, --all needs to be passed"
    )
    print(
        "\t-f, --single-file <filename>: (optional, defaults to .nasl) Allows to choose the file the script should be run against. Can be used together with -s, --startdir and the same rules on modified files applies as well"
    )
    print(
        "\t--non-recursive: (optional, only used together with -a, --all) Don't run the script recursive from the startdir"
    )
    print(
        "\t-c, --max-counter <int>: (optional, defaults to 100) Allows to choose the max amount of files the script should change in one run"
    )
    print(
        "\t--dry-run: (optional) Don't change any files, just show which and how many files would be affected if run without this option"
    )
    exit()


if len(sys.argv) > 1:
    try:
        opts, args = getopt.getopt(
            sys.argv[1:],
            "hmas:f:c:",
            [
                "help",
                "modified-only",
                "staged-only",
                "commit-range=",
                "all",
                "start-dir=",
                "single-file=",
                "non-recursive",
                "max-counter=",
                "dry-run",
            ],
        )
    except getopt.GetoptError:
        print(
            "ERROR: Non-existent option given or option requiring an argument is given none. See below for the usage.\n"
        )
        help()
    for opt, arg in opts:
        if opt == "-h" or opt == "--help":
            help()
        elif opt == "-m" or opt == "--modified-only":
            modified_only = True
        elif opt == "-a" or opt == "--all" or opt == "--batch":
            modified_only = False
        elif opt == "-s" or opt == "--start-dir":
            start_dir = arg
        elif opt == "-f" or opt == "--single-file":
            single_file = arg
        elif opt == "--non-recursive":
            recursive = False
        elif opt == "--dry-run":
            dry_run = True
        elif opt == "--staged-only":
            staged_only = True
        elif opt == "--commit-range":
            use_commit_range = True
            passed_commit_range = arg
        elif opt == "-c" or opt == "--max-counter":
            try:
                max_changed_counter = int(arg)
            except ValueError:
                print("ERROR: No integer passed to option", opt, "\n")
                help()


def subprocess_cmd(command):
    process = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True)
    proc_stdout = process.communicate()[0].strip()
    return proc_stdout


def check_and_replace(file):

    global cur_changed_counter

    try:
        modified = False
        text = open(file, encoding="iso-8859-1").read()

        # nb: Automatically generated by CSV2NASL Generators, don't touch them at all these will
        # get overwritten again automatically.
        if "huawei/gb_euleros_" in file or "suse/gb_sles_" in file:
            return

        # Remove obsolete 'nvt' parameter
        get_app_nvt = re.finditer(
            "get_app_(port|version|location)[\\s]*\([^\\n]*([,(][\\s]*nvt:[^,)\\n]*)[^\\n]*",
            text,
        )
        if get_app_nvt is not None:
            for occurrence in get_app_nvt:
                if occurrence is not None and occurrence.group(2) is not None:
                    cleaned_text = occurrence.group(0).replace(
                        occurrence.group(2), ""
                    )
                    text = text.replace(occurrence.group(0), cleaned_text)
                    modified = True

        # Remove obsolete 'nvt' parameter in register_host_detail
        register_host = re.finditer(
            "register_(host_detail|cpe)[\\s]*\([^\\n]*([,(][\\s]*nvt:[^,)\\n]*)[^\\n]*",
            text,
        )
        if register_host is not None:
            for occurrence in register_host:
                if occurrence is not None and occurrence.group(2) is not None:
                    cleaned_text = occurrence.group(0).replace(
                        occurrence.group(2), ""
                    )
                    text = text.replace(occurrence.group(0), cleaned_text)
                    modified = True

        # Replace SCRIPT_OID variable
        oid_var = re.search(
            "script_oid[\\s]*\([\\s]*([^\"')]*)[\\s]*\)[\\s]*;", text
        )
        if oid_var is not None and oid_var.group(1) is not None:
            oid = re.search(
                "[\\s]*"
                + oid_var.group(1).replace("(", "\(").replace(")", "\)")
                + "[\\s]*=[\\s]*[\"']([^\"']*)[\"'][\\s]*;",
                text,
            )

            if oid is not None and oid.group(1) is not None:
                text = text.replace(oid.group(0), "")
                text = text.replace(oid_var.group(1), '"' + oid.group(1) + '"')
                modified = True

        # Replace SCRIPT_NAME variable
        name_var = re.search(
            "script_name[\\s]*\([\\s]*([^\"')]*)[\\s]*\)[\\s]*;", text
        )
        if name_var is not None and name_var.group(1) is not None:
            name = re.search(
                "[\\s]*"
                + name_var.group(1).replace("(", "\(").replace(")", "\)")
                + "[\\s]*=[\\s]*[\"']([^\"']*)[\"'][\\s]*;",
                text,
            )

            if name is not None and name.group(1) is not None:
                text = text.replace(name.group(0), "")
                text = re.sub(
                    "[ \\t]*script_name[ ]*\\([ ]*" + name_var.group(1),
                    '  script_name("' + name.group(1) + '"',
                    text,
                )
                modified = True

        # Replace SCRIPT_FAMILY variable
        family_var = re.search(
            "script_family[\\s]*\([\\s]*([^\"')]*)[\\s]*\)[\\s]*;", text
        )
        if family_var is not None and family_var.group(1) is not None:
            family = re.search(
                "[\\s]*"
                + family_var.group(1).replace("(", "\(").replace(")", "\)")
                + "[\\s]*=[\\s]*[\"']([^\"']*)[\"'][\\s]*;",
                text,
            )

            if family is not None and family.group(1) is not None:
                text = text.replace(family.group(0), "")
                text = re.sub(
                    "[ \\t]*script_family[ ]*\\([ ]*" + family_var.group(1),
                    '  script_family("' + family.group(1) + '"',
                    text,
                )
                modified = True

        # Replace other SCRIPT_OID variables
        script_vars = re.finditer("\n[ \\t]*SCRIPT_OID[^\\n\\r]*", text)
        if script_vars is not None:
            for var in script_vars:
                text = text.replace(var.group(0), "")
                modified = True

        # Other variable text need to be replaced also
        tag_vars = re.finditer(
            "script_tag[\\s]*\([\\s]*name[\\s]*:[^,]*,[\\s]*value[\\s]*:[\\s]*([^\"')]*)[\\s]*\)[\\s]*;",
            text,
        )
        if tag_vars is not None:
            for var in tag_vars:
                tag_value = re.search(
                    "[\\s]*"
                    + var.group(1).replace("(", "\(").replace(")", "\)")
                    + "[\\s]*=[\\s]*[\"']([\\s\\S]*?)[\"'][\\s]*;",
                    text,
                )
                if tag_value is not None and tag_value.group(1) is not None:
                    text = text.replace(tag_value.group(0), "")
                    text = text.replace(
                        var.group(1),
                        '"' + tag_value.group(1).replace('"', "'") + '"',
                    )
                    modified = True

        # Replace ';' with ',' in script tags
        tag_vars = re.finditer(
            'script_tag[\\s]*\([\\s]*name[\\s]*:[^,]*,[\\s]*value[\\s]*:[\\s]*["]([^"]*)["][\\s]*\)[\\s]*;',
            text,
        )
        if tag_vars is not None:
            for var in tag_vars:
                new_tag = var.group(1).replace(";", ",")
                if new_tag != var.group(1):
                    text = text.replace(var.group(1), new_tag)
                    modified = True

        # Replace unnecessary "variable initializations" (and its various variants)
        var_inits = re.search(
            "(##? ?([Vv]ariables? )?[Ii]ni(tia|tai)li[sz](e|ation)[\\s\\S]+?;(\\n|\\r\\n|\\r){2})",
            text,
        )
        if var_inits is not None and var_inits.group(0) is not None:
            text = text.replace(var_inits.group(0), "")
            modified = True

        # Replace unnecessary "Code starts here"
        code_start = re.search(
            "(#[\\s\n#]+([Tt]he [Ss]cript )?[Cc]ode [Ss]tarts (from )?[Hh]ere[\\s#]*([\n][#]*)?)",
            text,
        )
        if code_start is not None and code_start.group(1) is not None:
            text = text.replace(code_start.group(1), "")
            modified = True

        # Replace unnecessary "Not vulnerable."
        not_vuln = re.search(
            "(exit[\\s]*\\([\\s]*99[\\s]*\\)[\\s]*;)[\\s*]#[\\s]*Not vulnerable[\\.]?",
            text,
        )
        if not_vuln is not None and not_vuln.group(1) is not None:
            text = text.replace(not_vuln.group(0), not_vuln.group(1))
            modified = True

        # Replace broken version check English with proper English
        check_version = re.search(
            "([Gg]et[\\s]*the[\\s]*installed[\\s]*version[\\s]*with[\\s]*the[\\s]*help[\\s]*of[\\s]*detect[\\s]*NVT[\\s]*and[\\s]*check[\\s]*i?f? ?the[\\s]*version[\\s]*is[\\s]*vulnerable[\\s]*or[\\s]*not[.]?)",
            text,
        )
        if check_version is not None and check_version.group(1) is not None:
            text = text.replace(
                check_version.group(1),
                "Checks if a vulnerable version is present on the target host.",
            )
            modified = True
        check_patch = re.search(
            "([Gg]et[\\s]*the[\\s]*vulnerable[\\s]*file[\\s]*version[\\s]*and[\\s]*check[\\s]*i?f? ?appropriate[\\s]*patch[\\s]*is[\\s]*applied[\\s]*or[\\s]*not[.]?)",
            text,
        )
        if check_patch is not None and check_patch.group(1) is not None:
            text = text.replace(
                check_patch.group(1),
                "Checks if a vulnerable version is present on the target host.",
            )
            modified = True
        check_google = re.search(
            '([Gg]et[\\s]*the[\\s]*installed[\\s]*version[\\s]*of[\\s]*[^"]*[\\s]*(with|and)[^"]*)',
            text,
        )
        if check_google is not None and check_google.group(1) is not None:
            text = text.replace(
                check_google.group(1),
                "Checks if a vulnerable version is present on the target host.",
            )
            modified = True
        check_help = re.search(
            '([Gg]et[\\s]*the[\\s]*installed[\\s]*version[\\s]*with[\\s]*the[\\s]*help[^"]*)',
            text,
        )
        if check_help is not None and check_help.group(1) is not None:
            text = text.replace(
                check_help.group(1),
                "Checks if a vulnerable version is present on the target host.",
            )
            modified = True
        check_through = re.search(
            '([Gg]et[\\s]*the[\\s]*installed[\\s]*version[\\s]*through[^"]*and[\\s]*check[^"]*)',
            text,
        )
        if check_through is not None and check_through.group(1) is not None:
            text = text.replace(
                check_through.group(1),
                "Checks if a vulnerable version is present on the target host.",
            )
            modified = True
        check_service_pack = re.search(
            '([Gg]et[\\s]*the[\\s]*installed[\\s]*service[\\s]*pack[\\s]*version[^"]*)',
            text,
        )
        if (
            check_service_pack is not None
            and check_service_pack.group(1) is not None
        ):
            text = text.replace(
                check_service_pack.group(1),
                "Checks if a vulnerable version is present on the target host.",
            )
            modified = True
        vuldetect_vers_match = re.search(
            '(script_tag\(name:"vuldetect", value:"Checks? the version\.?"\);)',
            text,
        )
        if (
            vuldetect_vers_match is not None
            and vuldetect_vers_match.group(0) is not None
        ):
            text = text.replace(
                vuldetect_vers_match.group(0),
                'script_tag(name:"vuldetect", value:"Checks if a vulnerable version is present on the target host.");',
            )
            modified = True
        vuldetect_os_match = re.search(
            '(script_tag\(name:"vuldetect", value:"Checks? the OS build\.?"\);)',
            text,
        )
        if (
            vuldetect_os_match is not None
            and vuldetect_os_match.group(0) is not None
        ):
            text = text.replace(
                vuldetect_os_match.group(0),
                'script_tag(name:"vuldetect", value:"Checks if a vulnerable OS build is present on the target host.");',
            )
            modified = True
        if (
            'Description truncated, for more information please check the Reference URL");'
            in text
        ):
            text = text.replace(
                'Description truncated, for more information please check the Reference URL");',
                'Description truncated, please see the referenced URL(s) for more information.");',
            )
            modified = True

        # Replace unnecessary "Get/Set statements"
        variable_get_set = re.search(
            "[^#](\n[ ]*#+ ?([Vv]ulnerable [Uu][Rr][Ll]|[GgSs]et |[Ss]end[s]?( (the |a )?[Rr]equest)? [Aa]nd [Rr]eceive|[Ff]etch|[Oo]pen ([Tt]he )?(UDP|udp|TCP|tcp)? ?[Ss]ocket|[Cc]los(e|ing) ([Tt]he )?(FTP|Telnet|SSH)? ?[Ss]ocket|[Cc]heck|[Ii]terate|[Tt]ry|[Cc]onfirm|[Cc]onstruct|[Bb]uild|[Gg]rep|[Rr]egister|[Cc]onstant|[Ww]indows|[Ll]inux]|[Tt]raversal_files\(\) [Ff]unction [Rr]eturns [Dd]ictionary|[Ww]ait|[Ss]leep)[s]?(ing)?(ed)?(ation)?[^\r\n]*)",
            text,
        )
        while (
            variable_get_set is not None
            and variable_get_set.group(1) is not None
        ):
            var = variable_get_set
            # Known text from the following VTs which shouldn't be replaced:
            # find_service2.nasl
            # gb_cisco_pis_ssh_detect.nasl
            # Commented out set_kb_item calls in GSHB/
            # Required comments in Policy/VRP
            if (
                "# Trying 10.10" not in var.group(1)
                and "Build : 3.0" not in var.group(1)
                and "set_kb_item(name" not in var.group(1)
                and "Build Number : 6" not in var.group(1)
                and "Policy/VRP/MulticastProtocolSecurity/" not in file
                and "build date      :" not in var.group(1)
            ):
                text = text.replace(var.group(1), "", 1)
                modified = True
            else:
                break
            variable_get_set = re.search(
                "[^#](\n[ ]*#+ ?([Vv]ulnerable [Uu][Rr][Ll]|[GgSs]et|[Ss]end[s]?( (the |a )?[Rr]equest)? [Aa]nd [Rr]eceive|[Ff]etch|[Oo]pen ([Tt]he )?(UDP|udp|TCP|tcp)? ?[Ss]ocket|[Cc]los(e|ing) ([Tt]he )?(FTP|Telnet|SSH)? ?[Ss]ocket|[Cc]heck|[Ii]terate|[Tt]ry|[Cc]onfirm|[Cc]onstruct|[Bb]uild|[Gg]rep|[Rr]egister|[Cc]onstant|[Ww]indows|[Ll]inux]|[Tt]raversal_files\(\) [Ff]unction [Rr]eturns [Dd]ictionary|[Ww]ait|[Ss]leep)[s]?(ing)?(ed)?(ation)?[^\r\n]*)",
                text,
            )

        # Remove "Check" expressions
        check_matches = re.finditer(
            "[^\r\n]*[#]+[ ]*([Tt]hunderbird|[Ss]ea[Mm]onkey|[Hh]ot[Ff]ix|[Ff]irefox|[Pp]ower[Pp]oint( Viewer)?)[ ]*[Cc]heck[^\r\n]*\n",
            text,
        )
        if check_matches is not None:
            for check_match in check_matches:
                text = text.replace(check_match.group(0), "")
                modified = True

        # Remove redundant brackets in regex expressions
        bracket_set = re.finditer('((\!|=)~.*("|\^)\([0-9]+\))', text)
        if bracket_set is not None:
            for bracket in bracket_set:
                new_text = bracket.group(1).replace("(", "").replace(")", "")
                text = text.replace(bracket.group(1), new_text)
                modified = True

        # Correctly escape dots in regex
        dot_set = re.finditer(
            "((\!|=)~[^\"']*[\"'][^\"']([0-9]+[.][0-9]*)+[\"'])", text
        )
        if dot_set is not None:
            for dot in dot_set:
                new_text = dot.group(1)
                if new_text[-1] == '"':
                    new_text = dot.group(1).replace(".", "\\.")
                elif new_text[-1] == "'":
                    new_text = dot.group(1).replace(".", "\\\\.")
                text = text.replace(dot.group(1), new_text)
                modified = True

        # Make security_message() display some sort of message at least
        empty_solution_set = re.finditer(
            "(security_message[ ]*\([ ]*0[ ]*\))", text
        )
        if empty_solution_set is not None:
            for empty_solution in empty_solution_set:
                new_text = 'security_message( port: 0, data: "The target host was found to be vulnerable" )'
                text = text.replace(empty_solution.group(1), new_text)
                modified = True

        # Replace obsolete dependency on "secpod_reg_enum.nasl" with "smb_reg_service_pack.nasl"
        # if no "hotfix_missing()" or similar functions of secpod_reg.inc are used.
        reg_enum_match = re.search(
            'script_dependencies[ ]*\\([^)]*([ ]*"secpod_reg_enum.nasl"[ ]*[,]?[ ]*)',
            text,
        )
        reg_sp_match = re.search(
            'script_dependencies[ ]*\\([^)]*([ ]*"smb_reg_service_pack.nasl"[ ]*[,]?[ ]*)',
            text,
        )
        if reg_enum_match is not None and reg_enum_match.group(1) is not None:
            hf_missing = re.search(
                "(hotfix_missing|hotfix_check_domain_controler|hotfix_check_nt_server|hotfix_check_exchange_installed|hotfix_check_iis_installed)[ ]*\\(.*\\)",
                text,
            )
            if hf_missing is None or hf_missing.group(1) is None:
                modified = True
                if (
                    reg_sp_match is not None
                    and reg_sp_match.group(1) is not None
                ):
                    text = text.replace(reg_enum_match.group(1), "")
                else:
                    # To bring in some consistency to the script_dependencies call
                    if reg_enum_match.group(1).endswith(
                        ", "
                    ) or reg_enum_match.group(1).endswith(","):
                        text_reg_replace = '"smb_reg_service_pack.nasl", '
                    else:
                        text_reg_replace = '"smb_reg_service_pack.nasl"'

                    text = text.replace(
                        reg_enum_match.group(1), text_reg_replace
                    )

        # The following functions are doing SMB requests and need a script_require_ports(139, 445);
        # nb: There might be more but those should be most common ones:
        # get_version(), GetVersion(), fetch_file_version(), registry_enum_values(), registry_enum_keys(), GetVer(), GetVersionFromFile(),
        # registry_get_dword(), registry_get_binary(), registry_get_sz(), registry_open_hklm(), registry_open_hkcu(), registry_open_hku(),
        # registry_get_key(), registry_get_item_sz(), registry_key_exists(), smb_session_request(), smb_neg_prot(), smb_session_setup(),
        # session_extract_uid(), smb_tconx(), tconx_extract_tid(), smbntcreatex(), smbntcreatex_extract_pipe(), pipe_accessible_registry(),
        # win_cmd_exec(), smb_read_file(), is_killbit_set())
        # The following functions have no parameters so they have a different reges: kb_smb_transport(), smb_get_systemroot(), smb_get_system32root()
        smb_func_match = re.search(
            "(((smb_get_systemroot|smb_get_system32root|kb_smb_transport)[ ]*\\([ ]*\\);)|(get_version|GetVersion|fetch_file_version|registry_enum_values|registry_enum_keys|GetVer|GetVersionFromFile|registry_get_dword|registry_get_binary|registry_get_sz|registry_open_hklm|registry_open_hkcu|registry_open_hku|registry_get_key|registry_get_item_sz|registry_key_exists|smb_session_request|smb_neg_prot|smb_session_setup|session_extract_uid|smb_tconx|tconx_extract_tid|smbntcreatex|smbntcreatex_extract_pipe|pipe_accessible_registry|win_cmd_exec|smb_read_file|is_killbit_set) ?\\([^)]+\\))",
            text,
            re.MULTILINE,
        )
        script_ports_match = re.search(
            "(script_require_ports[ ]*\(([^)]+)\))", text
        )
        script_smb_ports_match = re.search(
            "(script_require_ports\(139,[ ]*445\)[ ]*;)", text
        )

        # We don't want to add the script_require_ports or script_mandatory_keys to the
        # PCIDSS and GSHB VTs as those are doing some reporting like failed logins or missing ports on
        # their own and this would hide the message. gb_ipswitch_imail_server_detect.nasl
        # is another special case which has an own get_version call.
        if (
            "gsf/PCIDSS/" not in file
            and "GSHB/" not in file
            and "Policy/" not in file
            and "win_AdvancedPolicySettings.nasl" not in file
            and "gb_ipswitch_imail_server_detect.nasl" not in file
        ):

            dep_match = re.search(
                "(script_dependencies[ ]*\\([^)]+\\)[ ]*;)", text
            )

            # Found one of the SMB functions above...
            if (
                smb_func_match is not None
                and smb_func_match.group(0) is not None
            ):

                # ... and script_ports so try to see if it already contains 139 and 445
                if (
                    script_ports_match is not None
                    and script_ports_match.group(2) is not None
                ):
                    # If we don't have both...
                    if "139" not in script_ports_match.group(
                        2
                    ) and "445" not in script_ports_match.group(2):
                        # ... add it
                        text = text.replace(
                            script_ports_match.group(2),
                            script_ports_match.group(2) + ", 139, 445",
                        )
                        modified = True

                # ... but no script_require_ports, we need to add script_require_ports(139, 445);
                if (
                    script_ports_match is None
                    or script_ports_match.group(1) is None
                ):
                    if dep_match is not None and dep_match.group(1) is not None:
                        text = text.replace(
                            dep_match.group(1),
                            dep_match.group(1)
                            + "\n  script_require_ports(139, 445);",
                        )
                        modified = True

            # If there is still a dependency to secpod_reg_enum.nasl (which is the case for VTs up to 2012) after the removal
            # above we need to verify that a script_mandatory_keys to "SMB/registry_enumerated" is there. Also replace any
            # occurrence of "SMB/WindosVersion" with the more correct key namend previously.
            if (
                dep_match is not None
                and dep_match.group(1) is not None
                and "secpod_reg_enum.nasl" in dep_match.group(1)
            ):
                mandatory_match = re.search(
                    "(script_mandatory_keys[ ]*\(([^)]+)\))", text
                )
                if (
                    mandatory_match is not None
                    and mandatory_match.group(2) is not None
                ):
                    if "SMB/WindowsVersion" in mandatory_match.group(
                        2
                    ) and "SMB/registry_enumerated" not in mandatory_match.group(
                        2
                    ):
                        text = text.replace(
                            mandatory_match.group(0),
                            mandatory_match.group(0).replace(
                                '"SMB/WindowsVersion"',
                                '"SMB/registry_enumerated"',
                            ),
                        )
                        modified = True
                    elif "SMB/WindowsVersion" in mandatory_match.group(
                        2
                    ) and "SMB/registry_enumerated" in mandatory_match.group(2):
                        text = text.replace(
                            mandatory_match.group(0),
                            mandatory_match.group(0).replace(
                                '"SMB/WindowsVersion",', ""
                            ),
                        )
                        text = text.replace(
                            mandatory_match.group(0),
                            mandatory_match.group(0).replace(
                                ',"SMB/WindowsVersion"', ""
                            ),
                        )
                        modified = True
                    elif "SMB/registry_enumerated" not in mandatory_match.group(
                        2
                    ):
                        text = text.replace(
                            mandatory_match.group(0),
                            mandatory_match.group(0).replace(
                                ")", ', "SMB/registry_enumerated")'
                            ),
                        )
                        modified = True

        # Found script_require_ports(139, 445); ...
        if (
            script_smb_ports_match is not None
            and script_smb_ports_match.group(0) is not None
        ):

            # ... but none of the SMB functions above...
            if smb_func_match is None or smb_func_match.group(0) is None:

                # Special cases were the script_require_ports should be kept
                if (
                    "gb_wmi_access.nasl" not in file
                    and "gb_authenticated_scan_lsc_smb_login_consolidation.nasl"
                    not in file
                ):

                    # ... then we just remove the script_require_ports(139, 445);
                    text = text.replace(script_smb_ports_match.group(0), "")
                    modified = True

        # Replace bad english in the summary tag of detection scripts
        detection_english_match = re.search(
            "(Detection of installed version of)", text
        )
        if (
            detection_english_match is not None
            and detection_english_match.group(1) is not None
        ):
            text = text.replace(
                detection_english_match.group(1),
                "Detects the installed version of",
            )
            modified = True

        # Replace various other variants of bad english
        detection_english_match = re.search(
            "((,|\.)?\s*For\s+(updates|details)\s+refer\s+to(\s+the)?\s+Referenced?\s+links?\.?)",
            text,
            re.IGNORECASE,
        )
        if (
            detection_english_match is not None
            and detection_english_match.group(1) is not None
        ):
            text = text.replace(
                detection_english_match.group(1),
                ". Please see the references for more information.",
            )
            modified = True

        detection_english_match = re.search(
            "(Run\s+Windows\s+Update\s+and\s+update\s+the\s+listed\s+hotfixes\s+or\s+download\s+and\s+update\s+mentioned\s+hotfixes\s+in\s+the\s+advisory\s+(below|at\s+the\+sreferences?|from\s+the\s+((given|referenced?)\s+link|references|referenced\s+advisory)|from\s+the\s+link\s+mentioned\s+in\s+reference)?\.?)",
            text,
            re.IGNORECASE,
        )
        if (
            detection_english_match is not None
            and detection_english_match.group(1) is not None
        ):
            text = text.replace(
                detection_english_match.group(1),
                "The vendor has released updates. Please see the references for more information.",
            )
            modified = True

        detection_english_match = re.search(
            '"(Run\s+Windows\s+Update\s+and\s+(update|install)\s+the\s+listed\s+hotfixes\s+or\s+download\s+and\s+(update|install\s+the)\s+(mentioned\s+)?hotfixes\s+(in|from)(\s+the)?(\s+referenced)?\s+(advisory|avdisory)\.?(\s*(For\s+(details|updates)\s+refer\s+to(\s+the)?\s+reference\s+links?|Please\s+see\s+the\s+references\s+for\s+more\s+information)\.?)?)"',
            text,
            re.IGNORECASE,
        )
        if (
            detection_english_match is not None
            and detection_english_match.group(1) is not None
        ):
            text = text.replace(
                detection_english_match.group(1),
                "The vendor has released updates. Please see the references for more information.",
            )
            modified = True

        detection_english_match = re.search(
            "(script\s*sends\s*HTTP\s*GET\s*request\s*and\s*try\s*to)",
            text,
            re.IGNORECASE,
        )
        if (
            detection_english_match is not None
            and detection_english_match.group(1) is not None
        ):
            text = text.replace(
                detection_english_match.group(1),
                "script sends an HTTP GET request and tries to",
            )
            modified = True

        detection_english_match = re.search(
            "(script\s*sends\s*HTTP GET\s*requests\s*and\s*try\s*to)",
            text,
            re.IGNORECASE,
        )
        if (
            detection_english_match is not None
            and detection_english_match.group(1) is not None
        ):
            text = text.replace(
                detection_english_match.group(1),
                "script sends HTTP GET requests and tries to",
            )
            modified = True

        # Remove spaces in script tags for uniformity
        script_tags = re.finditer(
            "(?![A-Za-z_-])[ \\t]*((script_add_preference|script_[^ag][a-z]+)[\\S\\s]+?\\)[ ]*;)",
            text,
            re.MULTILINE,
        )

        if script_tags is not None:
            for tag_match in script_tags:
                if tag_match.group(1) is not None:
                    tag = tag_match.group(1)
                    new_tag = tag
                    if "Revision" not in tag and "script_name(" not in tag:
                        new_tag = re.sub('[ ]*:[ ]*["]', ':"', new_tag)
                        new_tag = re.sub("[ ]*:[ ]*[']", ":'", new_tag)
                        new_tag = new_tag.replace("Date:2", "Date: 2")

                        # Don't break the double points in the value of script_tags.
                        # For example don't change something like e.g.:
                        #
                        # script_tag(name:"summary", value:"This is a test: 'foo'");
                        #
                        # to:
                        #
                        # script_tag(name:"summary", value:"This is a test:'foo'");
                        #
                        if new_tag != tag and "script_tag" in tag:
                            value_match = re.search(
                                'script_tag[ ]*\([ ]*name[ ]*:[ ]*"[^"]+"[ ]*,[ ]*value[ ]*:[ ]*"([^"]+)"',
                                tag,
                            )
                            if (
                                value_match is not None
                                and value_match.group(1) is not None
                            ):
                                new_value_match = re.search(
                                    'script_tag[ ]*\([ ]*name[ ]*:[ ]*"[^"]+"[ ]*,[ ]*value[ ]*:[ ]*"([^"]+)"',
                                    new_tag,
                                )
                                if (
                                    new_value_match is not None
                                    and new_value_match.group(1) is not None
                                ):
                                    new_tag = new_tag.replace(
                                        new_value_match.group(1),
                                        value_match.group(1),
                                    )

                    # only first occurrence
                    new_tag = re.sub("[ ]*\\([ ]*", "(", new_tag, 1)

                    # only last occurrence
                    new_tag = re.sub("[ ]*\\)[ ]*", ")", new_tag[::-1], 1)[::-1]

                    new_tag = re.sub("[ ]+,", ",", new_tag)
                    # nb: Don't break the comma in script_xref URLs...
                    if not "script_xref" in tag:
                        new_tag = re.sub(",[ ]*(?![\\r\\n])", ", ", new_tag)

                    if re.search(
                        'script_tag\(name\s*:\s*"(summary|impact|affected|insight|vuldetect|solution)',
                        new_tag,
                    ):
                        # nb: Don't break something like e.g. the following in a summary tag:
                        #
                        # through 99,999 minutes
                        #
                        number_match = re.search("( [0-9]+,[0-9]+ )", tag)
                        if (
                            number_match is not None
                            and number_match.group(1) is not None
                        ):
                            new_number_match = re.search(
                                "( [0-9]+, [0-9]+ )", new_tag
                            )
                            if (
                                new_number_match is not None
                                and new_number_match.group(1) is not None
                            ):
                                new_tag = new_tag.replace(
                                    new_number_match.group(1),
                                    number_match.group(1),
                                )

                        # Similar to above a comma might be put into "()" like e.g.:
                        #
                        # can be separated by commas (,)
                        #
                        bracket_match = re.search("(\(,\))", tag)
                        if (
                            bracket_match is not None
                            and bracket_match.group(1) is not None
                        ):
                            new_bracket_match = re.search("(\(, \))", new_tag)
                            if (
                                new_bracket_match is not None
                                and new_bracket_match.group(1) is not None
                            ):
                                new_tag = new_tag.replace(
                                    new_bracket_match.group(1),
                                    bracket_match.group(1),
                                )

                        # Another case which is used regularely but getting broken by Pandora:
                        #
                        # (inode,0,DIRENT_HTREE)
                        #
                        # TODO

                        # Another special case is the following in the script_tag of gb_dont_scan_fragile_device.nasl.
                        # Pandora would replace 5060:all:full,443:tcp:tlsonly with 5060:all:full, 443:tcp:tlsonly here.
                        if "gb_dont_scan_fragile_device.nasl" in file:
                            continue

                    # Don't break the comma in "name" and "value" of script_add_preference...
                    # e.g. in gb_dont_scan_fragile_device.nasl the script would replace 5060:all:full,443:tcp:tlsonly with 5060:all:full, 443:tcp:tlsonly in script_add_preference
                    # The same happens with fingerprint1,Fingerprint2 in gb_ssl_weak_hash_algo.nasl which gets fingerprint1, Fingerprint2
                    #
                    # nb: Both parts below expect that the script_add_preference starts with the name: parameter.
                    if new_tag != tag and "script_add_preference" in tag:
                        name_match = re.search(
                            'script_add_preference[ ]*\([ ]*name[ ]*:[ ]*"([^"]+)"',
                            tag,
                        )
                        if (
                            name_match is not None
                            and name_match.group(1) is not None
                        ):
                            new_name_match = re.search(
                                'script_add_preference\(name:"([^"]+)"', new_tag
                            )
                            if (
                                new_name_match is not None
                                and new_name_match.group(1) is not None
                            ):
                                new_tag = new_tag.replace(
                                    new_name_match.group(1), name_match.group(1)
                                )

                        value_match = re.search(
                            'script_add_preference[ ]*\([ ]*name[ ]*:[ ]*"[^"]+"([ ]*,[ ]*type[ ]*:[ ]*"[^"]+")?[ ]*,[ ]*value[ ]*:[ ]*"([^"]+)"',
                            tag,
                        )
                        if (
                            value_match is not None
                            and value_match.group(2) is not None
                        ):
                            new_value_match = re.search(
                                'script_add_preference\(name:"[^"]+"(, type:"[^"]+")?, value:"([^"]+)"',
                                new_tag,
                            )
                            if (
                                new_value_match is not None
                                and new_value_match.group(2) is not None
                            ):
                                new_tag = new_tag.replace(
                                    new_value_match.group(2),
                                    value_match.group(2),
                                )

                    if new_tag != tag:
                        text = text.replace(tag, new_tag)
                        modified = True

        # Move urls from script_tags to script_xref
        url_matches = re.finditer(
            '[\\s]*([Ff]rom[\\s]*the[\\s]*[Ll]ink[s]?[\\s]*mentioned[\\s]*below|from[\\s]*below[\\s]*link[s]?|from[\\s]*link[s]?[\\s]*below|from[\\s]*the[\\s]*link[s]?[\\s]*below|from[\\s]*the[\\s]*below[\\s]*link[s]?|[Ff]or[\\s]*[Dd]etails[\\s]*[Rr]efer[\\s]*[to ]{0,3}|[Ff]or[\\s]*[more ]{0,5}[Ii]nformation[\\s]*refer[\\s]*to|[Ff]or[\\s]*[more ]{0,5}updates[,]?[\\s]*[,]?refer[\\s]*to|[Ff]or[\\s]*[Uu]pdates[\\s]*[Rr]efer[\\s]*[to ]{0,3}|[Rr]efer to|[Ff]or[\\s]*[Uu]pdates[\\s]*head[\\s]*[to ]{0,3}| Please visit this link to learn more)[: \n\r,.]* ?(http[^ "]+)',
            text,
        )
        if url_matches is not None:
            for url_match in url_matches:
                if url_match.group(2) is not None:
                    text = text.replace(url_match.group(0), "")
                    if url_match.group(2) not in text:
                        text = re.sub(
                            "exit[ ]*\([ ]*0[ ]*\)[ ]*;",
                            'script_xref(name:"URL", value:"'
                            + url_match.group(2)
                            + '");\n  exit(0);',
                            text,
                            1,
                        )
                    modified = True

        url_matches = re.finditer(
            "[\\s]*[Ss]ee (http[^\\s]*)[\\s]*for[e]?[\\s]*more[\\s]*information[\\s.,]*",
            text,
        )
        if url_matches is not None:
            for url_match in url_matches:
                if url_match.group(1) is not None:
                    text = text.replace(url_match.group(0), "")
                    if url_match.group(1) not in text:
                        text = re.sub(
                            "exit[ ]*\([ ]*0[ ]*\)[ ]*;",
                            'script_xref(name:"URL", value:"'
                            + url_match.group(1)
                            + '");\n  exit(0);',
                            text,
                            1,
                        )
                    modified = True

        url_matches = re.finditer(
            '[Uu](pgrade|pdate)[\\s]*to[\\s]*a?[\\s]*newer[\\s]*version[\\s]*if[\\s]*available[\\s]*at[\\s]*(http[^\\s"]*)',
            text,
        )
        if url_matches is not None:
            for url_match in url_matches:
                if url_match.group(2) is not None:
                    text = text.replace(
                        url_match.group(0),
                        "Update to a newer version if available.",
                    )
                    if url_match.group(2) not in text:
                        text = re.sub(
                            "exit[ ]*\([ ]*0[ ]*\)[ ]*;",
                            'script_xref(name:"URL", value:"'
                            + url_match.group(2)
                            + '");\n  exit(0);',
                            text,
                            1,
                        )
                    modified = True

        # Fix "Windows" affected tags to use newlines.
        # e.g. something like:
        #
        # script_tag(name:"affected", value:"Microsoft Windows xyz, Microsoft Windows zxy");
        #
        # or:
        #
        # script_tag(name:"affected", value:"Microsoft Windows xyz,
        # Microsoft Windows zxy");
        #
        # should get:
        #
        # script_tag(name:"affected", value:"- Microsoft Windows xyz
        #
        # - Microsoft Windows zxy");
        #
        # but something like e.g.:
        #
        # script_tag(name:"affected", value:"Microsoft Windows xyz");
        #
        # should be kept (without a dash) and only a final "." should get added.
        #
        # There are also a few special cases like e.g.:
        #
        # script_tag(name:"affected", value:"- Microsoft .NET Framework 4.6, 4.6.1, 4.6.2,
        # 4.7, 4.7.1, and 4.7.2 on Microsoft Windows 8.1 for 32-bit/x64");
        #
        # which we shouldn't break (not adding a - before the second Microsoft Windows,
        # not adding a newline before the second one, ...)
        #
        affected_match = re.search(
            '^([ \\t]*script_tag[ \\t]*\([ \\t]*name[ \\t]*:[ \\t]*"affected"[ \\t]*,[ \\t]*value[ \\t]*:[ \\t]*"([ \\t-]*(Microsoft|Windows) [^"]+)"[ \\t]*\)[ \\t]*;)',
            text,
            re.MULTILINE | re.IGNORECASE,
        )
        if affected_match is not None and affected_match.group(2) is not None:

            original_sub_tag_match = affected_match.group(2)

            # A few VTs have already a broken tag like e.g. the following which needs to be fixed first because they are messing up the search / replace below:
            # script_tag(name:"affected", value:"- Microsoft .NET Framework 4.6, 4.6.1, 4.6.2,
            # 4.7, 4.7.1, and 4.7.2 on
            #
            # - Microsoft Windows 8.1 for 32-bit/x64
            new_sub_str = re.sub(
                " *on\s+- (Microsoft )?Windows *",
                "##--pandora-on-windows-replace-pattern--##",
                original_sub_tag_match,
                flags=re.MULTILINE | re.IGNORECASE,
            )

            # First replace all newlines so that we have a clean "start" for later processing.
            # There are just too many special cases to cover them all in different regexes.
            #
            # The first replacements have a special meaning to easier replace these later:
            new_sub_str = re.sub(
                "(^|\n)[ \\t]*-[ \\t]+(Microsoft )?Windows ",
                "##--pandora-windows-dash-replace-pattern--##",
                new_sub_str,
                flags=re.MULTILINE | re.IGNORECASE,
            )
            new_sub_str = re.sub(
                "(^|\n)[ \\t]*-[ \\t]+Microsoft ",
                "##--pandora-other-ms-dash-replace-pattern--##",
                new_sub_str,
                flags=re.MULTILINE | re.IGNORECASE,
            )

            # and then just drop the newlines while making sure that there are not more the one trailing space...
            new_sub_str = re.sub(
                "\.\n[ \\t]+", ". ", new_sub_str, flags=re.MULTILINE
            )
            new_sub_str = re.sub(
                ",\n[ \\t]+", ", ", new_sub_str, flags=re.MULTILINE
            )
            new_sub_str = re.sub(
                "\n[ \\t]{1,}", " ", new_sub_str, flags=re.MULTILINE
            )
            new_sub_str = re.sub("\n##--pandora-", "##--pandora-", new_sub_str)
            new_sub_str = new_sub_str.replace("\n", " ")

            # nb: Special handling for something like e.g. the following which would be broken later:
            #
            # script_tag(name:"affected", value:"- Microsoft .NET Framework 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, and 4.7.2 on Windows 7 SP1 and Server 2008 R2 SP1
            # script_tag(name:"affected", value:"Microsoft .NET Framework 4.5.2 on Windows Server 2012 R2 and Windows 8.1");
            # script_tag(name:"affected", value:"Microsoft Office 2016 and Office 2019 on Mac OS X");
            # script_tag(name:"affected", value:"Microsoft .NET Framework 4.5.2 for Windows 7 SP1, Server 2008 R2 SP1, and Server 2008");
            # script_tag(name:"affected", value:"Microsoft Office 2016 And Microsoft Excel 2016 Click-to-Run");
            #
            new_sub_str = re.sub(
                " *on (Microsoft )?Windows *",
                "##--pandora-on-windows-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )
            new_sub_str = re.sub(
                " *and (Microsoft )?Windows *",
                "##--pandora-and-windows-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )
            new_sub_str = re.sub(
                " *for (Microsoft )?Windows *",
                "##--pandora-for-windows-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )
            new_sub_str = re.sub(
                " *on Server *",
                "##--pandora-on-server-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )
            new_sub_str = re.sub(
                " *and Server *",
                "##--pandora-and-server-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )
            new_sub_str = re.sub(
                " *for Server *",
                "##--pandora-for-server-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )
            new_sub_str = re.sub(
                " *on Microsoft *",
                "##--pandora-on-other-ms-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )
            new_sub_str = re.sub(
                " *and Microsoft *",
                "##--pandora-and-other-ms-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )
            new_sub_str = re.sub(
                " *for Microsoft *",
                "##--pandora-for-other-ms-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )

            # Next step is to replace all remaining "Microsoft Windows" or "Windows" with the ##--pandora-windows-dash-replace-pattern--## pattern for later processing
            new_sub_str = re.sub(
                " *(Microsoft )?Windows ",
                "##--pandora-windows-dash-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )
            # Same for other non-Windows products
            new_sub_str = re.sub(
                " *Microsoft ",
                "##--pandora-other-ms-dash-replace-pattern--##",
                new_sub_str,
                flags=re.IGNORECASE,
            )

            # And finally replace all replacement pattern again and add a dash with a newline before them.
            new_sub_str = new_sub_str.replace(
                "##--pandora-windows-dash-replace-pattern--##",
                "\n\n  - Microsoft Windows ",
            )
            # Same for other non-Windows products
            new_sub_str = new_sub_str.replace(
                "##--pandora-other-ms-dash-replace-pattern--##",
                "\n\n  - Microsoft ",
            )

            # And for the "on xxx", "and xxx" and "on xxx" replace only the placeholder.
            new_sub_str = new_sub_str.replace(
                "##--pandora-on-windows-replace-pattern--##",
                " on Microsoft Windows ",
            )
            new_sub_str = new_sub_str.replace(
                "##--pandora-and-windows-replace-pattern--##",
                " and Microsoft Windows ",
            )
            new_sub_str = new_sub_str.replace(
                "##--pandora-for-windows-replace-pattern--##",
                " for Microsoft Windows ",
            )
            new_sub_str = new_sub_str.replace(
                "##--pandora-on-server-replace-pattern--##",
                " on Microsoft Windows Server ",
            )
            new_sub_str = new_sub_str.replace(
                "##--pandora-and-server-replace-pattern--##",
                " and Microsoft Windows Server ",
            )
            new_sub_str = new_sub_str.replace(
                "##--pandora-for-server-replace-pattern--##",
                " for Microsoft Windows Server ",
            )
            new_sub_str = new_sub_str.replace(
                "##--pandora-on-other-ms-replace-pattern--##", " on Microsoft "
            )
            new_sub_str = new_sub_str.replace(
                "##--pandora-and-other-ms-replace-pattern--##",
                " and Microsoft ",
            )
            new_sub_str = new_sub_str.replace(
                "##--pandora-for-other-ms-replace-pattern--##",
                " for Microsoft ",
            )

            # Finally some clean-up to e.g. sanitize the tag like e.g.:
            # - add a trailing "." for a single entries
            # - don't add a leading dash for single entries
            # - don't use a "." or "," for multiple entries
            patterns = re.finditer("(\n\n  - Microsoft [^\n]+)", new_sub_str)
            if patterns is not None:

                matches = tuple(patterns)
                matches_count = len(matches)

                # nb: We need to use "matches" instead of "patterns" here because the
                # iterator is already "consumed" and we can't iterate over it again.
                for pattern in matches:
                    value = pattern.group(1)
                    if value is not None:

                        if matches_count > 1:
                            if re.search("[\\.,]$", value):
                                new_value = re.sub("[\\.,]$", "", value)
                                new_sub_str = new_sub_str.replace(
                                    value, new_value
                                )

                            new_sub_str = re.sub("^\n\n  - ", "- ", new_sub_str)

                        elif matches_count == 1:
                            new_sub_str = new_sub_str.replace("\n\n  - ", "")
                            new_sub_str = re.sub(",$", "", new_sub_str)
                            if not new_sub_str.endswith("."):
                                new_sub_str += "."

            if not new_sub_str == original_sub_tag_match:
                full_original_tag = affected_match.group(1)
                new_original_tag = full_original_tag.replace(
                    original_sub_tag_match, new_sub_str
                )

                if not new_original_tag == full_original_tag:
                    modified = True
                    text = text.replace(full_original_tag, new_original_tag)

        # Unify spacing in description tag: 2 spaces before each script_ item
        script_tags = re.finditer(
            "([ \\t]*script_(oid|version|tag|cve_id|bugtraq_id|name|category|copyright|family|dependencies|require_ports|require_udp_ports|require_keys|mandatory_keys|exclude_keys|xref|timeout|add_preference)\\([^)]+)",
            text,
        )
        if script_tags is not None:
            for tag_match in script_tags:
                if tag_match.group(1) is not None:
                    tag = tag_match.group(1)
                    # Extra rule for no spaces, to allow the lookahead in the other pattern (which is necessary to avoid breaking script names containing 'script_')
                    if tag[0] == "s":
                        new_tag = "  " + tag
                    else:

                        # Don't break script_dependencies for VTs which have an "if" check for FEED_NAME.
                        # These have four spaces in front of script_dependencies.
                        if (
                            "    script_dependencies(" in tag
                            and "FEED_NAME" in text
                        ):
                            continue

                        # Similar case is gb_snmp_authorization.nasl which has a defined_func before
                        # and is using four spaces in front of the script_add_preferences.
                        if (
                            "    script_add_preference(" in tag
                            and "gb_snmp_authorization.nasl" in file
                        ):
                            continue

                        # Similar case are secpod_ssl_ciphers_setting.nasl and gb_policy_docker.nasl with six spaces.
                        if "      script_add_preference(" in tag:
                            if (
                                "secpod_ssl_ciphers_setting.nasl" in file
                                or "gb_policy_docker.nasl" in file
                            ):
                                continue

                        new_tag = re.sub(
                            "(?=[\\s])[ \\t]*script_", "  script_", tag
                        )
                    if new_tag != tag:
                        text = text.replace(tag, new_tag, 1)
                        modified = True

        # Same for the exit in description
        exit_match = re.search("([ ]*exit[ ]*\([ ]*0[ ]*\)[ ]*;[ ]*)\n}", text)
        if exit_match is not None and exit_match.group(1) is not None:
            new_text = text.replace(exit_match.group(1), "  exit(0);", 1)
            if new_text != text:
                text = new_text
                modified = True

        # Remove trailing newlines in script_tags
        matches = re.search('([ \\t]*[\n]+[ \\t]*"[ ]*\\)[ ]*;)', text)
        if matches is not None and matches.group(1) is not None:
            text = re.sub('([ \\t]*[\n]+[ \\t]*"[ ]*\\)[ ]*;)', '");', text)
            modified = True

        # Remove the http_keepalive.inc include if none of the related functions of it are used.
        ka_include_match = re.search(
            'include[ ]*\\([^)]*([ ]*"http_keepalive.inc"[ ]*[^;]+;)', text
        )
        if (
            ka_include_match is not None
            and ka_include_match.group(0) is not None
        ):
            ka_func_match = re.search(
                "((http_keepalive_send_recv|http_vuln_check|http_get_cache|check_win_dir_trav_ka|is_cgi_installed_ka|http_ka_recv_buf|http_check_remote_code|get_http_page) *\\(|xerox_printers.inc|gvr_apps_auth_func.inc)",
                text,
            )
            if ka_func_match is None or ka_func_match.group(0) is None:
                text = text.replace(ka_include_match.group(0), "")
                modified = True

        # Remove the global_settings.inc include if none of the related functions or variables of it are used.
        gs_include_match = re.search(
            'include[ ]*\\([^)]*([ ]*"global_settings.inc"[ ]*[^;]+;)', text
        )
        if (
            gs_include_match is not None
            and gs_include_match.group(0) is not None
        ):
            gs_func_match = re.search(
                "((log|debug)_print|(report|log)_verbosity|debug_level)", text
            )
            if gs_func_match is None or gs_func_match.group(0) is None:
                text = text.replace(gs_include_match.group(0), "")
                modified = True

        trail = re.search("([ \\t]+\r?\n)", text)
        if trail is not None and trail.group(1) is not None:
            text = re.sub("([ \\t]+\r?\n)", "\n", text)
            modified = True

        # Fix the remaining leading newline in the script tags like:
        # script_tag(name:"insight", value:"
        # This update for util-linux fixes the following issues:
        lead_newline = re.finditer(
            '(script_tag\(name:"(summary|impact|affected|insight|vuldetect|solution)", value:")([\\n\\t ]+)',
            text,
        )
        if lead_newline is not None:
            for lead_match in lead_newline:
                if lead_match.group(3) is not None:
                    text = text.replace(
                        lead_match.group(0), lead_match.group(1)
                    )
                    modified = True

        # Seems only 20 scripts are affected, and they already have a solution type
        # Still, keeping this for some time, if ever needed
        # Should be deleted if not used for at least 2 weeks
        # 2018-09-04

        #        ask_match = re.search('(script_tag\(name:"solution", value:"[^"]*[Aa]sk the vendor[^"]*);', text)
        #        if ask_match is not None and ask_match.group(0) is not None:
        #            if not re.search('script_tag\(name:"solution_type"', text):
        #               text = text.replace(ask_match(0), '''script_tag(name:"solution_type", value:"WillNotFix");
        # script_tag(name:"solution", value:"No known solution was made available for at least one year since the disclosure of this vulnerability
        # Likely none will be provided anymore.
        # General solution options are to upgrade to a newer release, disable respective features, remove the product or replace the product by another one.");''')

        # Fix the solution text for "WillNotFix" solution type
        correct_will_not_fix_pattern = 'script_tag\s*\(\s*name\s*:\s*"solution"\s*,\s*value\s*:\s*"(No\s+solution\s+(was\s+made\s+available\s+by\s+the\s+vendor|is\s+required)\.\s+Note:.+|(No\s+solution\s+was\s+made\s+available\s+by\s+the\s+vendor|No\s+known\s+solution\s+was\s+made\s+available\s+for\s+at\s+least\s+one\s+year\s+since\s+the\s+disclosure\s+of\s+this\s+vulnerability\.\s+Likely\s+none\s+will\s+be\s+provided\s+anymore)\.\s+General\s+solution\s+options\s+are\s+to\s+upgrade\s+to\s+a\s+newer\s+release,\s+disable\s+respective\s+features,\s+remove\s+the\s+product\s+or\s+replace\s+the\s+product\s+by\s+another\s+one\.)'
        will_not_fix_match = re.search(
            'script_tag\(name:"solution_type", value:"WillNotFix"', text
        )
        if (
            will_not_fix_match is not None
            and will_not_fix_match.group(0) is not None
        ):
            if not re.search(correct_will_not_fix_pattern, text):
                text_match = re.search(
                    'script_tag\(name:"solution", value:"([^"]+)', text
                )
                if text_match is not None and text_match.group(1) is not None:
                    # nb: Keep the newlines/linebreaks like currently used to have a correct indentation within the .nasl
                    text = text.replace(
                        text_match.group(1),
                        """No known solution was made available for at least one year since the disclosure
  of this vulnerability. Likely none will be provided anymore. General solution options are to upgrade to a newer
  release, disable respective features, remove the product or replace the product by another one.""",
                    )
                    modified = True

        script_tags = re.finditer(
            'script_tag\(name:"[^"]*", value:("[^"]*"\);)', text
        )
        if script_tags is not None:
            for tag in script_tags:
                if tag.group(1) is not None:
                    tag_value = tag.group(1)
                    tag_value = re.sub(
                        "[\n]{1,2}[ ]*-[ ]*", "\n\n  - ", tag_value
                    )
                    # nb: We're using [ ]+ here as some scripts might use something like *text* which shouldn't be changed for now...
                    tag_value = re.sub(
                        "[\n]{1,2}[ ]*\*[ ]+", "\n\n  * ", tag_value
                    )
                    if tag_value != tag.group(1):
                        text = text.replace(tag.group(1), tag_value)
                        modified = True

        # Alternatively to the above drop it completely...
        impact_tag = re.search(
            'script_tag\(name:"impact", value:"([^"]+)"', text
        )
        if impact_tag is not None and impact_tag.group(1) is not None:
            impact_level = re.search(
                "(\.?[\s]*[Ii]mpact [Ll]evel ?: ?(.+))", impact_tag.group(1)
            )
            if impact_level is not None and impact_level.group(0) is not None:
                text = text.replace(impact_level.group(0), ".")
                modified = True

        # Set a fitting solution_type
        type_tag_match = re.search('script_tag\(name:"solution_type"', text)
        if type_tag_match is None or type_tag_match.group(0) is None:
            solution_match = re.search(
                'script_tag\(name:"solution", value:"([^"]+)"\)', text
            )
            summary_match = re.search(
                'script_tag\(name:"summary", value:"([^"]+)"\)', text
            )
            vendor_fix_match = None
            if (
                solution_match is not None
                and solution_match.group(1) is not None
            ):
                vendor_fix_match = re.search(
                    "([Uu]pdates are available|[Uu]pgrade to|[Uu]pdate to|[Rr]un [Ww]indows [Uu]pdate)",
                    solution_match.group(1),
                )
                if (
                    vendor_fix_match is not None
                    and vendor_fix_match.group(1) is not None
                ):
                    text = text.replace(
                        'script_tag(name:"solution"',
                        'script_tag(name:"solution_type", value:"VendorFix");\n  script_tag(name:"solution"',
                    )
                    modified = True
            else:
                creation_year_match = re.search(
                    'script_tag\(name:"creation_date", value:"([0-9]{4})-', text
                )
                severity = 0
                severity_match = re.search(
                    'script_tag\(name:"cvss_base", value:"([0-9]{1,2})', text
                )
                if (
                    severity_match is not None
                    and severity_match.group(1) is not None
                ):
                    severity = int(severity_match.group(1))
                if (
                    creation_year_match is not None
                    and creation_year_match.group(1) is not None
                    and severity > 0
                ):
                    year = int(creation_year_match.group(1))
                    if year > 0 and year < 2018:
                        text = re.sub(
                            "exit[ ]*\([ ]*0[ ]*\)[ ]*;",
                            'script_tag(name:"solution_type", value:"WillNotFix");\n  script_tag(name:"solution", value:"'
                            + "No known solution was made available for at least one year\n"
                            + "  since the disclosure of this vulnerability. Likely none will be provided anymore.\n"
                            + "  General solution options are to upgrade to a newer release, disable respective features,\n"
                            + '  remove the product or replace the product by another one.");\n'
                            + "\n  exit(0);",
                            text,
                            1,
                        )
                        modified = True

        # Convert the sysPath to a named function parameter.
        if " = fetch_file_version(sysPath, file_name:" in text:
            text = text.replace(
                " = fetch_file_version(sysPath, file_name:",
                " = fetch_file_version(sysPath:sysPath, file_name:",
            )
            modified = True

        # Remove mentions of the KB in customer information (e.g. summary)
        kb_match = re.search(
            "script_tag\([^)]*?(,?\s*and\s*(save|store|set)s?\s*(it|the\s*version|the\s*information|the\s*result|the\s*reuslt|those)?s?\s*in\s*KB( item)?)",
            text,
        )
        if kb_match is not None and kb_match.group(1) is not None:
            text = text.replace(kb_match.group(1), "")
            modified = True

        # Remove superfluous / unnecessary text like the following in the summary tag:
        # - The host is installed with VLC media player and is prone to arbitrary code execution vulnerability.
        # - This host is running ownCloud and is prone to an access control bypass vulnerability.
        # and just use something like e.g. the following instead:
        # ownCloud is prone to an access control bypass vulnerability.
        drop_text = re.search(
            '(script_tag\s*\(\s*name\s*:\s*"summary"\s*,\s*value\s*:\s*"Th(e|is)\s+host\s+is\s+(installed|running)\s+(with\s*)?([^"]+)\s+(and|,?\s*which)\s+(is\s+(prone|vulnerable|affected)\s+(to|by)\s+([^"]+))"\s*\)\s*;)',
            text,
            re.MULTILINE | re.IGNORECASE,
        )
        if drop_text is not None and drop_text.group(1) is not None:
            replacement_text = (
                'script_tag(name:"summary", value:"'
                + drop_text.group(5)
                + " "
                + drop_text.group(7)
                + '");'
            )
            # nb: A few are using newlines with two following spaces, just use one space in that case for now.
            replacement_text = re.sub("\s{2,}", " ", replacement_text)
            # nb: And if a newline is used we want to just have a space so that the pattern below are matching
            replacement_text = re.sub("\n", " ", replacement_text)
            text = text.replace(drop_text.group(0), replacement_text)
            modified = True

        # After the "host is" fixes above finally fix a few "broken" (missing a/an, missing
        # abbreviation, ...) summary tags like e.g.:
        # - prone to arbitrary code execution vulnerability.
        # - prone to denial-of-service vulnerability.
        rewrite_text = re.search(
            '(script_tag\s*\(\s*name\s*:\s*"summary"\s*,\s*value\s*:\s*"[^"]+is\s+(prone|vulnerable|affected)\s+(to|by)\s+(unspecified|XML\s+External\s+Entity|integer\s+(und|ov)erflow|DLL\s+hijacking|(hardcoded?|default)\s+credentials?|open[\s-]+redirect(ion)?|user\s+enumeration|arbitrary\s+file\s+read|memory\s+corruption|use[\s-]+after[\s-]+free|man[\s-]+in[\s-]+the[\s-]+middle(\s+attack)?|cross[\s-]+site[\s-]+(scripting|request[\s-]+forgery)|denial[\s-]+of[\s-]+service|information\s+disclosure|(path|directory)\s+traversal|(arbitrary\s+|remote\s+)?((code|command)\s+(execution|injection)|file\s+inclusion)|SQL\s+injection|security|(local )?privilege[\s-]+(escalation|elevation)|(authentication|security|access)\s+bypass|(buffer|heap)\s+overflow)\s+vulnerability\.?)',
            text,
            re.MULTILINE | re.IGNORECASE,
        )
        if rewrite_text is not None and rewrite_text.group(1) is not None:
            old_tag_content = rewrite_text.group(1)
            vuln_name = rewrite_text.group(4)
            # nb: Some are writing the "V" uppercase
            new_tag_content = old_tag_content.replace(
                " Vulnerability", " vulnerability"
            )
            # Make the vulnerability name lowercase
            new_tag_content = new_tag_content.replace(
                vuln_name, vuln_name.lower()
            )
            # Rewrite stuff like denial-of-service to denial of service
            new_tag_content = new_tag_content.replace(
                "hardcode credential ", "hardcoded credentials"
            )
            new_tag_content = new_tag_content.replace(
                "hardcoded credential ", "hardcoded credentials"
            )
            new_tag_content = new_tag_content.replace(
                "hardcode credentials", "hardcoded credentials"
            )
            new_tag_content = new_tag_content.replace(
                "default credential ", "default credentials"
            )
            new_tag_content = new_tag_content.replace(
                "open-redirection", "open redirect"
            )
            new_tag_content = new_tag_content.replace(
                "open redirection", "open redirect"
            )
            new_tag_content = new_tag_content.replace(
                "open-redirect", "open redirect"
            )
            new_tag_content = new_tag_content.replace(
                "use-after free", "use after free"
            )
            new_tag_content = new_tag_content.replace(
                "use after-free", "use after free"
            )
            new_tag_content = new_tag_content.replace(
                "use-after-free", "use after free"
            )
            new_tag_content = new_tag_content.replace(
                "cross site scripting", "cross-site scripting"
            )
            new_tag_content = new_tag_content.replace(
                "cross site-scripting", "cross-site scripting"
            )
            new_tag_content = new_tag_content.replace(
                "cross site request forgery", "cross-site request forgery"
            )
            new_tag_content = new_tag_content.replace(
                "cross site-request forgery", "cross-site request forgery"
            )
            new_tag_content = new_tag_content.replace(
                "cross site-request-forgery", "cross-site request forgery"
            )
            new_tag_content = new_tag_content.replace(
                "cross site request-forgery", "cross-site request forgery"
            )
            new_tag_content = new_tag_content.replace(
                "cross-site-request-forgery", "cross-site request forgery"
            )
            new_tag_content = new_tag_content.replace(
                "denial-of-service", "denial of service"
            )
            new_tag_content = new_tag_content.replace(
                "denial-of service", "denial of service"
            )
            new_tag_content = new_tag_content.replace(
                "remote-code-execution", "remote code execution"
            )
            new_tag_content = new_tag_content.replace(
                "remote-code execution", "remote code execution"
            )
            new_tag_content = new_tag_content.replace(
                "remote-command-execution", "remote command execution"
            )
            new_tag_content = new_tag_content.replace(
                "remote-command execution", "remote command execution"
            )
            new_tag_content = new_tag_content.replace(
                "buffer-overflow", "buffer overflow"
            )
            new_tag_content = new_tag_content.replace(
                "heap-overflow", "heap overflow"
            )
            new_tag_content = new_tag_content.replace(
                "sql-injection", "sql injection"
            )
            # SQL, DLL and XML needs to be written in uppercase
            new_tag_content = new_tag_content.replace(
                "sql injection", "SQL injection"
            )
            new_tag_content = new_tag_content.replace(
                "dll hijacking", "DLL hijacking"
            )
            new_tag_content = new_tag_content.replace(
                "xml external entity", "XML external entity"
            )
            # Some have man-in-the-middle attack vulnerability, just throw out the "attack"
            new_tag_content = new_tag_content.replace(
                "man-in-the-middle attack", "man-in-the-middle"
            )
            # We want to write the following as "privilege escalation"
            new_tag_content = new_tag_content.replace(
                "privilege elevation", "privilege escalation"
            )
            new_tag_content = new_tag_content.replace(
                "privilege-elevation", "privilege escalation"
            )
            new_tag_content = new_tag_content.replace(
                "privilege-escalation", "privilege escalation"
            )
            # Add the abbreviation if applicable
            new_tag_content = new_tag_content.replace(
                "XML external entity", "XML external entity (XXE)"
            )
            new_tag_content = new_tag_content.replace(
                "man-in-the-middle", "man-in-the-middle (MITM)"
            )
            new_tag_content = new_tag_content.replace(
                "cross-site scripting", "cross-site scripting (XSS)"
            )
            new_tag_content = new_tag_content.replace(
                "cross-site request forgery",
                "cross-site request forgery (CSRF)",
            )
            new_tag_content = new_tag_content.replace(
                "denial of service", "denial of service (DoS)"
            )
            new_tag_content = new_tag_content.replace(
                "remote code execution", "remote code execution (RCE)"
            )
            new_tag_content = new_tag_content.replace(
                "remote command execution", "remote command execution (RCE)"
            )
            new_tag_content = new_tag_content.replace(
                "SQL injection", "SQL injection (SQLi)"
            )
            # Append a final dot to the string if missing
            if not new_tag_content.endswith("."):
                new_tag_content += "."
            # And finally prepend the "a/an"
            new_tag_content = new_tag_content.replace(
                "unspecified vulnerability", "an unspecified vulnerability"
            )
            new_tag_content = new_tag_content.replace(
                "XML external entity (XXE) vulnerability",
                "an XML external entity (XXE) vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "integer underflow vulnerability",
                "an integer underflow vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "integer overflow vulnerability",
                "an integer overflow vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "DLL hijacking vulnerability", "a DLL hijacking vulnerability"
            )
            new_tag_content = new_tag_content.replace(
                "hardcoded credentials vulnerability",
                "a hardcoded credentials vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "default credentials vulnerability",
                "a default credentials vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "user enumeration vulnerability",
                "a user enumeration vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "arbitrary file read vulnerability",
                "an arbitrary file read vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "memory corruption vulnerability",
                "a memory corruption vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "use after free vulnerability", "a use after free vulnerability"
            )
            new_tag_content = new_tag_content.replace(
                "man-in-the-middle (MITM) vulnerability",
                "a man-in-the-middle (MITM) vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "cross-site scripting (XSS) vulnerability",
                "a cross-site scripting (XSS) vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "cross-site request forgery (CSRF) vulnerability",
                "a cross-site request forgery (CSRF) vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "denial of service (DoS) vulnerability",
                "a denial of service (DoS) vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "information disclosure vulnerability",
                "an information disclosure vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "path traversal vulnerability", "a path traversal vulnerability"
            )
            new_tag_content = new_tag_content.replace(
                "directory traversal vulnerability",
                "a directory traversal vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "arbitrary code execution vulnerability",
                "an arbitrary code execution vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "arbitrary command execution vulnerability",
                "an arbitrary command execution vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "arbitrary code injection vulnerability",
                "an arbitrary code injection vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "arbitrary command injection vulnerability",
                "an arbitrary command injection vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "remote code execution (RCE) vulnerability",
                "a remote code execution (RCE) vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "remote command execution (RCE) vulnerability",
                "a remote command execution (RCE) vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "remote code injection vulnerability",
                "a remote code injection vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "remote command injection vulnerability",
                "a remote command injection vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "to code execution vulnerability",
                "to a code execution vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "to command execution vulnerability",
                "to a command execution vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "to code injection vulnerability",
                "to a code injection vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "to command injection vulnerability",
                "to a command injection vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "file inclusion vulnerability", "a file inclusion vulnerability"
            )
            new_tag_content = new_tag_content.replace(
                "SQL injection (SQLi) vulnerability",
                "an SQL injection (SQLi) vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "security vulnerability", "a security vulnerability"
            )
            new_tag_content = new_tag_content.replace(
                "to privilege escalation vulnerability",
                "to a privilege escalation vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "to local privilege escalation vulnerability",
                "to a local privilege escalation vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "authentication bypass vulnerability",
                "an authentication bypass vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "security bypass vulnerability",
                "a security bypass vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "access bypass vulnerability", "an access bypass vulnerability"
            )
            new_tag_content = new_tag_content.replace(
                "buffer overflow vulnerability",
                "a buffer overflow vulnerability",
            )
            new_tag_content = new_tag_content.replace(
                "heap overflow vulnerability", "a heap overflow vulnerability"
            )

            # And if the new tag differs from the old one write it back...
            if new_tag_content != old_tag_content:
                text = text.replace(old_tag_content, new_tag_content)
                modified = True

        # Finally fix some remaining comma in the script_tags which where left behind by URL rewrite from the tags into a script_xref
        if ',");' in text or ', ");' in text:
            trail_comma = re.finditer(
                '((script_copyright\("|script_tag\(name:"(summary|impact|affected|insight|vuldetect|solution)", value:")[^"]+"\);)',
                text,
            )
            if trail_comma is not None:
                for comma_match in trail_comma:
                    if comma_match.group(0) is not None:
                        if comma_match.group(0).endswith(
                            ',");'
                        ) or comma_match.group(0).endswith(', ");'):
                            if "script_copyright" in comma_match.group(0):
                                text = text.replace(
                                    comma_match.group(0),
                                    comma_match.group(0).replace(',");', '");'),
                                )
                                text = text.replace(
                                    comma_match.group(0),
                                    comma_match.group(0).replace(
                                        ', ");', '");'
                                    ),
                                )
                            else:
                                text = text.replace(
                                    comma_match.group(0),
                                    comma_match.group(0).replace(
                                        ',");', '.");'
                                    ),
                                )
                                text = text.replace(
                                    comma_match.group(0),
                                    comma_match.group(0).replace(
                                        ', ");', '.");'
                                    ),
                                )
                            modified = True

        if modified:
            if dry_run:
                print("Would have modified '" + file + "'")
                cur_changed_counter += 1
                if cur_changed_counter >= max_changed_counter:
                    print(
                        "Would have changed "
                        + str(cur_changed_counter)
                        + " files"
                    )
                    exit()
            else:
                to_write = open(file, "w", encoding="iso-8859-1")
                to_write.write(text)

                to_write.close()

                print("Modified '" + file + "'")
                cur_changed_counter += 1

                if cur_changed_counter >= max_changed_counter:
                    print("Changed " + str(cur_changed_counter) + " files")
                    exit()

    except Exception as e:
        print("Error in file '" + file + "'")
        print(e)


if modified_only:
    if staged_only:
        modified = (
            subprocess_cmd(
                "git --no-pager diff --cached --name-status | egrep '\.nasl$' | awk '/^\s*[AMR]/ { print $NF ; }'"
            )
            .decode("latin-1")
            .splitlines()
        )
    elif use_commit_range:
        modified = (
            subprocess_cmd(
                "git --no-pager diff --cached --name-status "
                + passed_commit_range
                + " | egrep '\.nasl$' | awk '/^\s*[AMR]/ { print $NF ; }'"
            )
            .decode("latin-1")
            .splitlines()
        )
    else:
        modified = (
            subprocess_cmd(
                "git -c color.status=false --no-pager status --short | egrep '\.nasl$' | awk '/^\s*[AMR]/ { print $NF ; }'"
            )
            .decode("latin-1")
            .splitlines()
        )
    if len(modified) > 0:
        has_modified = True
    for file in modified:
        check_and_replace(file)
else:
    for root, dirs, files in os.walk(start_dir):
        if not recursive and cur_recursion_level >= 1:
            break
        cur_recursion_level += 1
        for file_name in files:
            if file_name.endswith(single_file):
                file = os.path.join(root, file_name)
                check_and_replace(file)

if dry_run:
    print("Would have changed " + str(cur_changed_counter) + " files")
else:
    print("Changed " + str(cur_changed_counter) + " files")
    if cur_changed_counter > 0:
        print("Pandora made changes, please review via git diff")
        exit(-1)
if modified_only and not has_modified:
    print(
        'Note: "Modified only" mode requested but no modified or added VTs found.'
    )
exit(0)
